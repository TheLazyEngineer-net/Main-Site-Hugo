+++
title = 'About TheLazyEngineer'
linkTitle = 'About'
description = "About TheLazyEngineer.net"
[menus]
  [menus.main]
    name = 'About'
    weight = 100
+++

Robust systems are becoming increasingly hard to find with new technology.  We seem to be happy with technology that will only last five years.  It wasn't long ago that we had to replace our computers and phones every two years to be able to use the newest software.  Software breaks countless things with every major release, causing untold manhours of additional work.  The constant churn of new technology is endless and it grows tiresome.

Human beings are amazing at creating tools that last the test of time.  Axes and hatchets have been cutting wood (and unfortunately people) for millenia, wheels are still round and exceptionally useful, and the venerable stick has been moving things as a lever for all of recorded history.  What do these tools have in common?  Simplicity in function and form.

Simplicity is foundational to robustness and robust things are just nicer to use.  Who wants to spend half a day fixing something that was working fine last week but then had a software update?  Let's bring back robustness to our technology.  The information on this site is directed to this purpose.

### Site Purpose

1. To organize areas of scattered and neglected technical information -- [Docs](/docs)
2. A place for my opinionated, technical thoughts -- [Posts](/posts)
3. An excuse to learn to build a website from the ground up

### Audience

This site is written for people who have at least some background in technology.  Most of the content is at least tangentially related to software since that is where my expertise lies.  I will try to include resouces for learning more about topics in the [Docs](/docs) section, but this site is not intended as an early learning resource.  Instead, it is meant for those with some technical knowledge looking for more depth in the areas covered.

### Meaning of Lazy

The word *'lazy'* on this site has a meaning in the same spirit as in [programming](https://en.wikipedia.org/wiki/Lazy_evaluation): delay work until required and do the work only as often as necessary (ideally never or once).

You might think that this is a given in computer programs, but that's not how they generally work.  In most applications or web pages (equivalent these days), many things are initialized when the program starts: connections to remote sites and databases are established, background processes are started, files are opened for use, initial state is loaded...etc.  This is the delay that we notice when we open up a large application.  To make this startup time faster, lazy evaluation is often used for components that might not be used.  That way, the application start time will be faster at the cost of minor deplays when the components are initialized on eventual use.

Another way to think of this meaning of "lazy" is: there is already more than enough work to do, so don't add more work unless necessary.  Try to eliminate time consuming, repetitive work since it is rarely of greater value than some other, available work.  Embracing this laziness opens up time for more useful things (or often allows for more avaiable CPU cycles and RAM in computers).  This spirit of laziness can be seen in all human tools.  We created the wheel to avoid repeated trips.  We created the washing machine to save countless hours of hand-washing cloths.  We created computers to save millennia of manual calculations.

Humans are lazy by nature, and that trait keeps us moving forward in our exponential pursuit to avoid more work.

### Background

I am a Software Engineer.  I have been doing that kind of work for nearing two decades at this point.  I have always been paid to do text-based, backend work, so that is my main area of programming expertise.  I have also built computers and servers for as long as I have been programming and have taken up Linux systems administration as a hobby.  More recently, I have spent some time learning more about electronics, circuit design, and power systems.

My background and hobbies mean that I know a lot about computers.  However, computing is such a large field that there will always be more for me to learn.  That is why I love it.  There will always be people who know a lot more than me about any topic and have kernels of amazing knowledge to share.  If I get bored writing Java code, I can move on to Nix systems administration for a while.  There is always a new, relevant topic for me to learn more about.

I learned that I am a computer nerd later than many.  I started programming for the first time in college.  Before that, I thought that I should be a musician, but I hated practicing as much as was needed.  It was too idle for my brain, too claustraphobic in the university's practice rooms, and I knew that hours of daily practice were required to move to the next level.  Luckily, while coming to this realization, I saw a friend working on his Computer Science homework in C++.  It looked interesting and I started asking him more about it.  I signed up for the introductory course the next semester and have been hooked ever since.

### Privacy

Privacy will always be respected on this site.  Currently, no site analytics have been added.  If site-analytics are added, then the details will be laid out here.  They won't do anything scary.

#### *Thank you for visiting my website.  I hope that you find something useful.*
